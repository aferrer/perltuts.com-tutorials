=head1 NAME

Guia ràpida

=head1 LANGUAGE

ca

=head1 ABSTRACT

Aquest programa d'aprenentatge és una guia ràpida per a no programadors o inexperts. Prova de
cobrir els aspectes bàsics i ho fa de manera gradual.

=head1 DESCRIPTION

Aquest programa d'aprenentatge és una guia ràpida per a no programadors o inexperts. Prova de
cobrir els aspectes bàsics i ho fa de manera gradual.

=head1 TUTORIAL

=head2 Hola món!

Provem-ho amb un exemple senzill. Aquest és un exemple habitual en tots els programes d'aprenentatge i llibres de programació, que imprimeix "Hola món!". Proveu d'executar el
programa següent i hauríeu de veure'n la sortida.

    say 'Hola món!'

Aquí C<say> és una funció que accepta arguments i els imprimeix a la sortida.

=head3 Exercici

Proveu de corregir el codi següent per tal que imprimeixi 'Adéu':

    say ''

    __TEST__
    like($stdout, qr/Bye/, q/Hauria d'imprimir Adéu/);

=head2 Cinturó de seguretat

Sovint els programadors cometen errors que són perfectament correctes
des del punt de vista de la sintaxi del llenguatge però tenen
inconvenients lògics que generen errors molt difícils de detectar.

Per tal de detectar errors tipogràfics i sorpreses, Perl proporciona dos
pragmes molt útils, C<strict> i C<warnings>. Us recomanem utilitzar-los
en qualsevol tros de codi. Tots els exemples d'aquest programa
d'aprenentatge inclouen implícitament aquestes dues línies, tot i que no
es mostren per estalviar espai.

No us cal entendre el codi que hi ha a continuació, només cal que veieu
la diferència entre utilitzar els pragmes de seguretat

    use strict;
    use warnings;

    $x += 1;
    $y .= 'string';

    say 'ok';

i no utilitzar-los

    no strict;
    no warnings;

    $x += 1;
    $y .= 'string';

    say 'ok';

=head2 Números

Els números son enters (1, 2, 5) i de coma flotant (1.2, 1e5). No hi ha
diferència real entre ells. Perl els tracta de la mateixa manera i els
converteix automàticament. 

Proveu a imprimir els següents números:

    say 1;
    say 4.4;
    say 1.2e10;

Com podeu veure, cada sentència acaba amb C<;>. Això és com un punt que
utilitzem per separar frases.

=head3 Operadors aritmètics

Les manipulacions aritmètiques bàsiques inclouen: C<+> (suma), C<->
(resta), C<*> (multiplicació), C</> (divisió), C<**> (exponent) i C<%>
(mòdul).

    say 1 + (10/5) * 3

=head4 Exercici

Imprimiu el resultat de 5 elevat a 6.

    say
    __TEST__
    like($code, qr/\*\*/, q/Hauríeu d'utilitzar l'operador **/);
    like($stdout, qr/15625/, 'Hauria de ser 15625');

=head2 Cadenes de text

Les cadenes es declaren utilitzant les cometes simples o dobles. La
diferència entre elles no és important ara mateix. Al nostre exemple, el
C<'Hola món!'> era una cadena.

    say 'foo'

=head3 Operadors i funcions bàsiques de les cadenes

Les cadenes es poden concatenar (enganxar) utilitzant un C<.> com a
operador.

    say 'foo' . 'bar'

Amb l'operador C<x> podeu repetir les cadenes.

    say 'foo' x 3;

Normalment voldreu manipular les cadenes per obtenir-ne la longitud,
trobar-hi un símbol o una subcadena, etc. Les funcions bàsiques de
manipulació de cadenes inclouen length(), substr(), index(), rindex().

    say length 'foo';
    say substr 'foo', 1, 2;
    say index 'foo', 'o';
    say rindex 'foo', 'o';

=head4 Exercici

Imprimiu per pantalla la posició de la cadena C<'bol'> dins de la cadena
C<'futbol'>.

    say
    __TEST__
    like($code, qr/index/, q/Heu d'utilitzar la funció index/);
    like($stdout, qr/3/, q/Ha de ser a la posició 3/);

=head2 Llistes

Les llistes són, bé, llistes de valors. Es declaren utilitzant
parèntesis.

    say (1, 2, 3, 5)

Sovint podeu utilitzar intervals per estalviar una mica de tecleig:

    say (1 .. 5)

Això també funciona amb caràcters.

=head4 Exercici

Imprimiu una llista de caràcters de la C<'b'> a la C<'m'>.

    say
    __TEST__
    like($stdout, qr/bcdefghijklm/, q/Hauria d'imprimir bcdefghijklm/);

Evidentment, les llistes poden contenir no només números, sinó també
caràcters:

    say (1, 'hola', 2, 'vosaltres')

Les llistes utilitzades a dins d'altres lllistes s'aplanen:

    say (1, (2, 3, 4), 5)

=head2 Assignació i variables

En els llenguatges de programació l'assignació és una operació que
emmagatzema un valor en algun lloc de la memòria de l'ordinador al qual
es pot accedir amb el seu nom.

A Perl 5 hi ha tres tipus de dades integrats: escalars, vectors i
diccionaris (o vectors associatius). Els escalars poden contenir cadenes
i números. Els vectors són llistes ordenades d'escalars als quals
s'accedeix amb un índex. Els diccionaris són vectors associatius no
ordenats en què s'utilitzen claus per accedir als valors. Les variables
que contenen escalars, vectors o diccionaris duen el prefix C<$>, C<@>
i C<%> respectivament.

Les variables es declaren normalment utilitzant el mot C<my>. Per
exemple:

    my $x = 1;
    say $x;

=head4 Exercici

Assigneu a una varibe C<y> la cadena C<'Hola món!'> i imprimiu-la.

    my $
    say
    __TEST__
    like($stdout, qr/Hola món!/, q/Hauria d'imprimir "Hola món!"/)

=head3 Escalars

Depenent del que contingui la variable (un número o una cadena) hi ha
diferents operadors que podeu utilitzar.

Diguem que voleu sumar dos valors numèrics:

    my $x = 1;
    my $y = 2;

    say $x + $y;

O que voleu concatenar dues cadenes:

    my $x = 'Hola';
    my $y = 'vosaltres';

    say $x . $y

Si provéssiu d'utilitzar C<+> a les cadenes o C<.> als números es
convertirien automàticament al tipus adequat.

    my $x = 1;
    my $y = '2 cops';

    say $x . $y;
    say $x + $y;

Com podeu veure, al segon exemple la cadena '2 cops' s'ha convertit en
un número, en aquest cas 2.

=head4 Exercici

Concateneu i imprimiu la cadena C<'Resultat='> i la suma de C<42> i
C<13>.

    my $x = ;
    my $y = ;

    say

    __TEST__
    like($stdout, qr/55/, q/Hauria d'imprimir "Resultat=55"/);

=head3 Vectors

Els vectors poden contenir una llista d'escalars.

    my @vector = (1, 2, 3);

    say @vector;

Les manipulacions bàsiques dels vectors inclouen obtenir un element amb
l'índex (començant des del 0), obtenir el darrer índex, encuar i empilar
valors.

    my @vector = (1, 2, 3);

    # Obté el tercer element
    say $vector[2];

    # Obté el darrer índex
    say $#vector;

    # Encua el valor 4
    push @vector, 4;
    say @vector;

    # Desencua el darrer valor
    pop @vector;
    say @vector;

    # Desempila el primer valor
    shift @vector;
    say @vector;

    # Empila el valor 0
    unshift @vector, 0;
    say @vector;

Probablement us haureu adonat que quan s'accedeix a un element d'un
vector es canvia C<@> per C<$>, ja que l'element del vector és un
escalar, i els escalars duen el prefix C<$>.

=head4 Exercici

Donat el vector que conté la llista C<(1, 2, 3, 4)>, imprimiu el tercer
element.

    my @vector = ;
    say 

    __TEST__
    like($stdout, qr/3/, q/Hauria d'imprimir 3/)

=head3 Diccionaris

Els diccionaris o vectors associatius són col·leccions no-ordenades
d'escalars als que es pot accedir mitjançant una clau. Normalment la
clau és una cadena de text.

    my %diccionari = ('clau1', 'valor1', 'clau2', 'valor2');

Enlloc d'utilitzar la coma per a separar les claus i els valors, Perl
proporciona C<< => >> com a operador més llegible, per exemple:

    my %diccionari = (clau1 => 'valor1', clau2 => 'valor2');

=head3 Manipulacions bàsiques dels diccionaris

Com en el cas dels vectors, quan s'accedeix a una clau d'un diccionari,
la variable esdevé un escalar i per això s'utilitza el símbol C<$> i les
claus C<{}>:

    my %diccionari = (clau1 => 'valor1', clau2 => 'valor2');

    say $diccionari{clau1};

=head3 Obtenir totes les claus i valors d'un diccionari

    my %diccionari = (clau1 => 'valor1', clau2 => 'valor2');

    say keys %diccionari;
    say values %diccionari;

=head2 Context

El context és un concepte molt important a Perl. Hi ha dos contexts
principals: escalar i de llista. El context habitualment afecta com es
comporten les funcions i les variables. Això és similar al llenguatge
natural.

L'ús més popular del context és aconseguir la longitud d'un vector.
Normalment, quan utilitzeu un vector en context de llista,
aquest retorna tots els seus elements, mentre que si ho utilitzeu en
context escalar retorna la seva longitud.

    my @vector = (1, 2, 3);

    my @vector2 = @vector; # context de llista
    say @vector2;

    my $longitud = @vector; # context escalar
    say $longitud;

=head2 Operadors lògics i de comparació

Abans d'introduir els corresponents operadors de Perl, veiem els
conceptes bàsics de l'àlgebra booleana.

L'àlgebra booleana és una variant de l'àlgebra on en comptes de números
hi ha els valors C<0> i C<1>, on C<1> s'anomena C<cert> i C<0> s'anomena
C<fals>.

Igual que a l'àlgebra normal hi ha operacions com C<+>, C<*>, etc, les
operacions bàsiques a l'àlgebra booleana s'anomenen C<NOT>, C<AND> i
C<OR>. Com ja sabeu, a l'àlgebra booleana només tenim els valors C<cert>
i C<fals>. Això vol dir que no només s'utilitzen a les diferents
operacions, sinó que el resultat d'aquestes operacions és o bé C<cert> o
bé C<fals>. Anem a veure-les d'una en una.

=head3 Cert i Fals

No hi ha valors C<cert> i C<fals> a Perl. A Perl C<cert> és tot allò que
no és C<fals>, on C<fals> és tot allò que converteix a C<0>. Per
exemple: el mateix C<0>, C<''> (cadena buida) o C<undef>.

=head3 NOT

L'operador C<NOT> és un operador unari, el que significa que opera sobre
un únic valor. A Perl, l'operador C<NOT> és C<!>. La taula de la veritat
de C<NOT> és:

=begin html

<table style="width:10px">
    <thead>
        <tr>
            <td>x</td>
            <td>!x</td>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>0</td>
            <td>1</td>
        </tr>
        <tr>
            <td>1</td>
            <td>0</td>
        </tr>
    </tbody>
</table>

=end html

Veiem quins son els resultats d'utilitzar aquest operador sobre
diferents valors. Al següent exemple sumem C<0> als valors C<fals> ja
que sinó la funció C<say> imprimiria la cadena buida.

    say !0;
    say !1 + 0;
    say !'string that converts to 1' + 0;
    say !'';

=head3 AND

L'operador C<AND> és un operador binari, el que significa que opera
sobre dos valors. A Perl, l'operador C<AND> és C<&&>. La taula de la
veritat d'C<AND> és:

=begin html

<table style="width:10px">
    <thead>
        <tr>
            <td>x</td>
            <td>y</td>
            <td>&amp;&amp;</td>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>0</td>
            <td>0</td>
            <td>0</td>
        </tr>
        <tr>
            <td>1</td>
            <td>0</td>
            <td>0</td>
        </tr>
        <tr>
            <td>0</td>
            <td>1</td>
            <td>0</td>
        </tr>
        <tr>
            <td>1</td>
            <td>1</td>
            <td>1</td>
        </tr>
    </tbody>
</table>

=end html

Veiem quins son els resultats d'utilitzar aquest operador sobre
diferents valors.

    say 1 && 1;
    say 0 && 1;
    say 0 && 0;
    say 'string' && 1;

=head3 OR

L'operador C<OR> és un operador binari, el que significa que opera sobre
dos valors. A Perl l'operador C<OR> és C<||>. La taula de la veritat
d'C<OR> és:

=begin html

<table style="width:10px">
    <thead>
        <tr>
            <td>x</td>
            <td>y</td>
            <td>||</td>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>0</td>
            <td>0</td>
            <td>0</td>
        </tr>
        <tr>
            <td>1</td>
            <td>0</td>
            <td>1</td>
        </tr>
        <tr>
            <td>0</td>
            <td>1</td>
            <td>1</td>
        </tr>
        <tr>
            <td>1</td>
            <td>1</td>
            <td>1</td>
        </tr>
    </tbody>
</table>

=end html

Veiem quins son els resultats d'utilitzar aquest operador sobre
diferents valors.

    say 1 || 1;
    say 0 || 1;
    say 0 || 0;
    say 'string' || 0;

=head3 Prioritat

Com a l'àlgebra normal, els operadors de l'àlgebra boolean tenen la seva
prioritat, on diferents operadors s'avaluen abans que altres. L'ordre
d'avaluació dels operadors booleans és el següent:

    ! && ||

=head3 Combinacions

C<NOT>, C<AND> i C<OR> es poden combinar. També podeu utilitzar
parèntesis per canviar l'ordre del flux lògic:

    say (1 || 0) && 1

=head4 Exercici

Corregiu la següent sentència introduint parèntesis per tal que
imprimeixi una cadena buida en comptes de C<1>.

    say  !1 || 1 && 1
    __TEST__
    is($stdout, "\n", q/Hauria de ser una cadena buida/');

=head3 Operadors de comparació

Els operadors de comparació també retornen valors C<cert> i C<fals>,
però s'utilitzen amb números i cadenes. Com que Perl no distingeix
entre números i cadenes, hi ha dos grups diferents d'operadors de
comparació per a ells.

=begin html

<table>
    <tr>
        <td>==</td><td>!=</td><td>&lt;</td><td>&lt;=</td><td>&gt;</td><td>&gt;=</td>
    </tr>
    <tr>
        <td>eq</td><td>ne</td><td>lt</td><td>le</td><td>gt</td><td>ge</td>
    </tr>
</table>

=end html

Proveu aquest exemple:

    say 1 == 1;
    say 10 > 2;
    say 3 <= 3;

    say 'foo' ne 'bar';

=head2 Sentències condicionals

Les sentències condicionals us permeten canviar el flux del codi. Les
sentències condicionals operen amb els valors booleans que heu après al
capítol anterior i inclouen C<if/else/elsif> i C<unless>.

Quan el resultat d'una expressió entre parèntesis és cert, el bloc
de codi envoltat de claus s'avalua:

    if (1 == 1) {
        say 'Cert';
    }

    if (1 == 0) {
        say 'Fals';
    }

Si voleu fer quelcom quan l'expressió sigui falsa podeu utilitzar
C<else>:

    if (0) {
        say 'Cert';
    }
    else {
        say 'Fals';
    }

Si voleu avaluar de nou l'expressió, podeu utilitzar C<elsif>:

    my $x = 1;

    if ($x == 0) {
        say 'x és zero';
    } elsif ($x < 0) {
        say 'x és menys que zero';
    } else {
        say 'x és més que zero';
    }

També hi ha una forma breu per la sentència C<if>:

    my $x = 5;
    say 'Cert' if $x > 0;

C<unless> és el contrari d'C<if>, on és el valor fals el que determina
si el bloc s'executa, i no el cert.

    my $x = 5;
    say 'Cert' unless $x == 0;

Això és el mateix que:

    my $x = 5;
    say 'Cert' if !($x == 0);

Com ja sabeu, a Perl els valors certs són tot allò que no és zero, així
que la comparació amb 0 normalment no és necessària:

    my $x = 5;
    say 'True' unless $x;

=head3 Exercici

Corregiu aquest codi per tal que imprimeixi C<'Hola'> en comptes
d'C<'Adéu'> utilitzant operadors lògics i sense canviar el valor
d'C<$x>.

    my $x = 0;

    if ($x) {
        say 'Hola';
    }
    else {
        say 'Adéu';
    }
    __TEST__
    like($code, qr/\$x = 0/, q/No hauria de canviar el valor d'$x/);
    like($stdout, qr/Hola/, q/Hauria d'imprimir "Hola"/);

=head2 Loops

Loops are blocks that are evaluated several times. They are usually used for
repetitive actions, walking through the data structure etc.

=head3 For/Foreach

C<Foreach> loop is usually used for looping through the list or array. For
example:

    foreach my $element (1, 2, 3, 4, 5) {
        say $element;
    }

You can pass an array of course:

    my @array = (1 .. 5);
    foreach my $element (@array) {
        say $element;
    }

As you can see we create a special C<$element> variable that is aliased to every
array element on every iteration. Beware that by changing the C<$element> value
you change the actual value in the array:

    my @array = (1 .. 5);
    foreach my $element (@array) {
        $element *= 2;
    }

    foreach my $element (@array) {
        say $element;
    }

=head4 Exercise

Print only the even values from C<0> to C<10>:

    foreach my $element (...) {
        if (...) {
            ...
        }
    }
    __TEST__
    like($stdout, qr/0\n2\n4\n6\n8\n10/, 'Should print even values');

=head3 While

C<While> is a more advanced loop that iterates while the expression is true.

    my $i = 10;
    while ($i > 0) {
        say $i;

        $i = $i - 1;
    }

As soon as expression C<< $i > 0 >> becomes false the loop stops.

=head4 Exercise

Print only the odd values from C<0> to C<10>:

    my $i = ;
    while ($i ...) {
        if (...) {
            ...
        }
    }
    __TEST__
    like($stdout, qr/1\n3\n5\n7\n9/, 'Should print odd values');

=head3 Getting out of the loop

Often you want to terminate the loop without waiting until it finishes. You
usually use the C<last> keyword:

    my $i = 0;
    while ($i < 100) {
        last if $i == 10;

        say $i;

        $i = $i + 1;
    }

This loop will not iterate C<100> times because we terminate it when C<$i> is
C<10>.

=head2 Default variable

The most used special variable is C<$_>, which is a default scalar variable. To
understand it better let's look at the examples.

You're familiar with C<say> function. It prints whatever you pass as arguments.
But what happens when you don't pass any arguments? It takes data from the
default C<$_> variable.

    $_ = 'Hello';
    say;

Of course you don't usually need this functionality, but it can very useful when
using loops for examples:

    say for (1 .. 10);

By default C<for> loop sets a C<$_> variable and C<say> prints it.

Many embedded Perl functions use default variable when no arguments are passed.

=head2 Subroutines

Subroutines are functions that accept arguments and can return the result.
Usually subroutines are used to eliminate duplication in code, make it clearer
and more understandable.

Let's say you want to convert 5 miles to kilometers. You would write something
like this:

    # Convert 5 miles to kilometers
    say 5 * 1.609344

But what if you wanted to convert 10 miles to kilometers or any other arbitrary
number? In this case we create a subroutine that we can use lately.

    sub miles_to_kilometers {
        my ($miles) = @_;

        return $miles * 1.609344;
    }

    say miles_to_kilometers(5);
    say miles_to_kilometers(10);
    say miles_to_kilometers(42);

The subroutine needs a bit of explanation. C<my ($miles) = @_> is called
C<arguments unpacking>. In Perl arguments when passed to the subroutine go the
default array C<@_> (this is also a special Per variable, just like C<$_>). You
can use all the array-specific functions on the default array too of course.

=head3 Exercise

Write and use a subroutine that converts kilometers to miles and prints 4, 6, 19
kilometers converted to miles (one kilometer is 0.621371192 miles).

    sub kilometers_to_miles {
        my ...

        return ...
    }

    say kilometers_to_miles(4);
    say kilometers_to_miles(6);
    say kilometers_to_miles(9);
    __TEST__
    like($stdout, qr/2.485484768\n3.728227152\n5.592340728/,
        'Should print correct values')

=head2 Regular Expressions

Regular expressions are a big part of the Perl language. They are essential to
know and use when processing texts. And that's what Perl is good for.

In short, regular expressions are special patterns when applied to strings
either match them or not, capture various substrings, modify the initial substring
by substituting parts of it and so on.

The most common usage for regular expression is to find out if a particular
string can be found in another string.

    my $string = 'Hello, world!';
    if ($string =~ m/Hello/) {
        say 'We found Hello!';
    }

So here are two new things: C<=~> and C<m//> (C<m> is for C<match>). There is
also an opposite C<!~> which is evaluated to C<True> when the regular expression
is not matched.

    my $string = 'Hello, world!';
    if ($string !~ m/Bye/) {
        say 'No Bye was found';
    }

Regular expressions can be really sophisticated. For example we want to check if
a string has C<a> B<or> C<o> characters:

    my $string = 'Hello';
    if ($string =~ m/a|o/) {
        say 'a or o was found';
    }

=head3 Metacharacters

Some characters in regular expression (as C<|> in previous example) are special. They 

=head1 AUTHOR

Viacheslav Tykhanovskyi, C<vti@cpan.org>

=head1 TRANSLATOR

Alex Muntada, C<alexm@cpan.org>
